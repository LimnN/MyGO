# Go Tour

## 包、变量、函数

### 包

* 每个 Go 程序都是由包构成的。
* 程序从 `main` 包开始运行。
* 包名与导入路径的最后一个元素一致。
* 使用分组导入语句是更好的形式。

### 导出名

* 如果一个名字以大写字母开头，那么它就是已导出的。
* 在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。

### 函数

* 函数可以没有参数或接受多个参数。
* 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。
* 函数可以返回任意数量的返回值。
* Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。
* 没有参数的 `return` 语句返回已命名的返回值。
* 函数返回一列值得数据类型，有些功能不需要返回值，这种情况下返回类型不是必须的。

### 变量

* `var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。
* 变量声明可以包含初始值，每个变量对应一个。
* 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。
* 在函数中，简洁赋值语句`:=` 可在类型明确的地方代替 `var` 声明
* 函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。
* 指定变量类型，如果没有初始化，则变量默认为零值。

> `:=` 是一个声明语句（声明并初始化）
> `:=` 左侧必须包含未声明的变量
> `:=` 只能用在函数体中。
> 它的一个重要用途是用在`if`，`for`和`switch`语句的初始化，使变量成为一个“临时变量”，也就是变量的作用域仅限于这条语句。

### Go基本类型

* bool
* string
* int int8 int16 int32 int64
* uint uint8 uint16 uint32 uint64 uintptr
* byte (uint8)
* rune (int32)
* float32 float64
* complex64 complex128

### 零值

* 数值类型 `0`
* bool型 `false`
* 字符串型 `""`

### 类型转换

* 表达式 T(v) 将值 v 转换为类型 T。
* Go 在不同类型的项之间赋值时需要显式转换。

### 类型推导

* 在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），变量的类型由右值推导得出。
* 当右值声明了类型时，新变量的类型与其相同：

```go
var i int
j := i // j 也是一个 int
```

* 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于常量的精度：

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

### 常量

* 常量的声明与变量类似，只不过是使用 `const` 关键字。
* 常量可以是字符、字符串、布尔值或数值。
* 常量不能用 `:=` 语法声明。
* 数值常量是高精度的 值。

## 流程控制

### for循环

* Go 的 `for` 语句后面的三个构成部分外没有小括号， 大括号 `{ }` 则是必须的。
* 初始化语句和后置语句是可选的。
* `for` 是 Go 中的 `while`

```go
for ; sum < 10>; {
    sum += sum
}

for sum < 10 {
    sum += sum
}
```

* 无限循环

```go
for {
}
```

### if

* Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。
* 同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 `if` 之内。
* 在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用

### switch

* Go 自动提供了在这些语言中每个 `case` 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。
* `switch` 的 `case` 无需为常量，且取值不必为整数。
* `switch` 的 `case` 语句从上到下顺次执行，直到匹配成功时停止。
* 没有条件的 `switch` 同 `switch true` 一样。这种形式能将一长串 `if-then-else` 写得更加清晰。

### defer

* `defer` 语句会将函数推迟到外层函数返回之后执行。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
* 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

## 高级类型

### 指针

* 类型 *T 是指向 T 类型值的指针。其零值为 nil。
* & 操作符会生成一个指向其操作数的指针。
* 操作符表示指针指向的底层值。
* Go 没有指针运算。

### 结构体

* 一个结构体（struct）就是一组字段（field）。
* 结构体字段使用点号访问
* 结构体字段可以通过结构体指针来访问。如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X` 就可以。
* 结构体文法

### 数组

* 类型 `[n]T` 表示拥有 n 个 `T` 类型的值的数组。
* 数组的长度是其类型的一部分，因此数组不能改变大小。

### 切片

* 类型 `[]T` 表示一个元素类型为 `T` 的切片。
* 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。
* 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。
* 切片并不存储任何数据，它只是描述了底层数组中的一段。
* 更改切片的元素会修改其底层数组中对应的元素。
* 切片文法
* 切片下界的默认值为 `0`，上界则是该切片的长度。
* 切片的长度就是它所包含的元素个数。切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。
* 切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。
* `nil` 切片的长度和容量为 `0` 且没有底层数组。

* 切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。
* `make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：
* 要指定它的容量，需向 `make` 传入第三个参数
* 为切片追加新的元素，当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。
* 如果切片的容量小于 1024，则扩容时其容量大小乘以2；一旦容量大小超过 1024，则增长因子变成 1.25，即每次增加原来容量的四分之一。
* `for` 循环的 `range` 形式可遍历切片或映射。当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。
