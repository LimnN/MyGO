# Go Tour

## 包

* 每个 Go 程序都是由包构成的。
* 程序从 `main` 包开始运行。
* 包名与导入路径的最后一个元素一致。
* 使用分组导入语句是更好的形式。

## 导出名

* 如果一个名字以大写字母开头，那么它就是已导出的。
* 在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。

## 函数

* 函数可以没有参数或接受多个参数。
* 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。
* 函数可以返回任意数量的返回值。
* Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。
* 没有参数的 `return` 语句返回已命名的返回值。
* 函数返回一列值得数据类型，有些功能不需要返回值，这种情况下返回类型不是必须的。

## 变量

* `var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。
* 变量声明可以包含初始值，每个变量对应一个。
* 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。
* 在函数中，简洁赋值语句`:=` 可在类型明确的地方代替 `var` 声明
* 函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。
* 指定变量类型，如果没有初始化，则变量默认为零值。

> `:=` 是一个声明语句（声明并初始化）
> `:=` 左侧必须包含未声明的变量
> `:=` 只能用在函数体中。
> 它的一个重要用途是用在`if`，`for`和`switch`语句的初始化，使变量成为一个“临时变量”，也就是变量的作用域仅限于这条语句。

## Go基本类型

* bool
* string
* int int8 int16 int32 int64
* uint uint8 uint16 uint32 uint64 uintptr
* byte (uint8)
* rune (int32)
* float32 float64
* complex64 complex128

## 零值

* 数值类型 `0`
* bool型 `false`
* 字符串型 `""`

## 类型转换

* 表达式 T(v) 将值 v 转换为类型 T。
* Go 在不同类型的项之间赋值时需要显式转换。

## 类型推导

* 在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），变量的类型由右值推导得出。
* 当右值声明了类型时，新变量的类型与其相同：

```go
var i int
j := i // j 也是一个 int
```

* 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于常量的精度：

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

## 常量

* 常量的声明与变量类似，只不过是使用 `const` 关键字。
* 常量可以是字符、字符串、布尔值或数值。
* 常量不能用 `:=` 语法声明。
* 数值常量是高精度的 值。

## for循环

* Go 的 `for` 语句后面的三个构成部分外没有小括号， 大括号 `{ }` 则是必须的。
* 初始化语句和后置语句是可选的。
* `for` 是 Go 中的 `while`

```go
for ; sum < 10>; {
    sum += sum
}

for sum < 10 {
    sum += sum
}
```

* 无限循环

```go
for {
}
```

## if

* Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。
* 同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 `if` 之内。
* 在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用

## switch

* Go 自动提供了在这些语言中每个 `case` 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。
* `switch` 的 `case` 无需为常量，且取值不必为整数。
* `switch` 的 `case` 语句从上到下顺次执行，直到匹配成功时停止。
* 没有条件的 `switch` 同 `switch true` 一样。这种形式能将一长串 `if-then-else` 写得更加清晰。

## defer

* `defer` 语句会将函数推迟到外层函数返回之后执行。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
* 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。
